# -*- coding: utf-8 -*-
"""DataAnalytics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/vjbarayuga/FinalTerm_Reference/blob/main/DataAnalytics.ipynb
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style(style="darkgrid")# "whitegrid")
# %matplotlib inline 
# use this command so that your plots appear inline in your notebook

from platform import python_version
print("python",python_version())
print('\n'.join(f'{m.__name__} {m.__version__}' for m in globals().values() if getattr(m, '__version__', None)))

## Lets First Load the Dataset
df_train = pd.read_csv("https://raw.githubusercontent.com/atulpatelDS/Data_Files/master/Titanic/titanic_train.csv")
df_train.head()

## Use PassengerId as Index
df_train = df_train.set_index("PassengerId")
df_train.head()

# Setting the X and y
# We have to predict whether the passenger survived or not so our target(Output) variable will be "Survived" 
# and remaiming columns will be Predictors(Input variables)
y = targets = labels = output_var = df_train["Survived"]
X = predictors = input_var = df_train.loc[:,df_train.columns != "Survived"]

y.head()

X.head()

# Print the Target and Input Variables
print("Input Variables", list(X.columns))
print("Output Variable", "['Survived']")

df_train.info()

datatype = df_train.dtypes
#col = datatype[(datatype == 'object') | (datatype == 'int64')| (datatype == 'float64')].index.tolist()
num_col = datatype[(datatype == 'float64') | (datatype == 'int64')].index.tolist()
cat_col = datatype[(datatype == 'object')].index.tolist()
print("Categorical Columns :",cat_col)
print("Numerical Columns :",num_col)

# Run descriptive statistics of numerical datatypes.
df_train.describe(include = ['float64','int64'])

"""Univariate Analysis

We explore variables one by one.
Method to perform uni-variate analysis will depend on whether the variable type is categorical or continuous.
Continuous Variable Analysis

Measure of central tendency(Mean, Median, Mode) of the variable.
Measure of spread(Range,IQR, Variance,Standard Deviation) of the variable.
Measure of Shape(Symmetrical Distribution e.g. Normal Distribution,Asymmetrical Distribution (Left or Right Skewed Distribution),Kurtosis(shape of the of the distribution in terms of height or flatness)
"""

# Lets Analysis the Target Variable "Survived"
# Calculate the percentage of people who Survived and Not Survived
df_train["Survived"].value_counts()

per_sur_nonsur = (df_train["Survived"].value_counts()/df_train.shape[0]*100).round(2)
per_sur_nonsur
# 0 > not-Survived
# 1 > Survived

"""# Univariate"""

# Lets plot the graph who are survided and not survied as per the column data
sns.countplot(data=df_train,x="Survived")

"""# Bivariate"""

sns.catplot(x="Sex",col="Survived",data=df_train, kind="count",height=4, aspect=.7)

"""# Multivariate"""

# Lets more elaborate survived data with Pclass and sex and we will use catplot
sns.catplot(data=df_train,col = "Survived",x = "Sex", hue="Pclass",kind = "count")

## Co-relation matrix
fig,ax = plt.subplots(figsize = (10,6))
corr = df_train.corr()
sns.heatmap(corr,annot=True)

"""# Data Cleaning"""

# If you use the method sum() along with it, then it will return the total number of the duplicates in the dataset
df_train.duplicated().sum()

# lets find out the percentage of misssing value in each column
percent_missing = df_train.isnull().sum() * 100 / len(df_train)
missing_value_df = pd.DataFrame({'column_name': df_train.columns,
                                 'percent_missing': percent_missing})
missing_value_df

"""# Impute Missing Value"""

# Impute missing age with median
df_train['Age'].fillna(df_train['Age'].mean(), inplace = True)

# lets find out the percentage of misssing value in each column
percent_missing = df_train.isnull().sum() * 100 / len(df_train)
missing_value_df = pd.DataFrame({'column_name': df_train.columns,
                                 'percent_missing': percent_missing})
missing_value_df